这个一个微型框架
可以实现MVC方式 
也可以单独使用数据库模型，当作数据类使用就可以了。
也方便嵌入你现有的项目中。本数据库操作强大
单独使用本内核文中后面有具体介绍。
整个内核也是30多KB
$supply=M("supply"); //new 数据库中的表名，目前是模型名，
                     //可以在supplyBase.class.php中修改表名
$books=M("books");
echo $supply->Books->classname;//自动取得Books中内容
echo $supply->Books->Supply->title; //反过来取supply中的内容
echo $supply->title;
echo $books->classname; 


支持path_info方式

控制动作在router目录下面
/default/index
调用router目录下面defaultRouter.class.php文件
取得类后调用index方式
J()是index方法跳转
R()是由控制
C()是生成类
M()是数据库类模型 
P()是加载路径函数

inc.ini.php
里面设置数据库链接和缺省方法，支持多库链接和多个链接，分布式数据库 主/从链接

只包括framework.php文件就可以了。
在项目中文件包含下面代码就可以了
	<?php
	//产品环境使用(Product)
	//$projectenv="product"; $projectenv="test";
	$projectenv="product";
	$config["webprojectpath"]=dirname(__FILE__)."/";
	include("framework/framework.php");
	?>

路由说明
	path_info方式
	testframework.php?router=default&action=index
	testframework.php/default/index

	可以使用apache重写 去掉testframework.php文件

	可以自己设置路由规则
	C("router")->ruleMaps("login",'/login/:id', array('controller' => 'auth', 'action' => 'login'));
	那么会配匹testframework.php/login/5555
	这样可以使用$_GET['id']得到5555;
	'controller' => 'auth', 'action' => 'login'
	是控制器和方法

	其它设置 可以添加自己定义的路由规则
	C("router")->ruleMaps('logout','/logout', array('controller' => 'auth', 'action' => 'logout'));
	C("router")->ruleMaps('signup','/signup', array('controller' => 'auth', 'action' => 'signup'));
	C("router")->ruleMaps('profile','/profile/:action', array('controller' => 'profile')); // will call controller "Profile" with dynamic method ":action()"
	C("router")->ruleMaps('users','/users/:id', array('controller' => 'users'), array('id' => '[\d]{1,8}')); // define filters for the url parameters


数据库数据模型
使用方法

	构造一个数据库表模型
	$beian=M('beian');

	自动填充aaa bbb字段 $_POST中也要有这两个字段
	//$beian->autoField(array("aaa","bbbb"));
	$data中填充
	$beian->autoField($data,array("aaa","bbbb"));
	取两个主键值，排序为升序
	//print_r($beian->get(53,54,'asc'));

	赋值给字段。
	$beian->userid=2;
	$beian->language=1;


	打印已经赋值字段
	//print_r($beian->data);

	保存，再显示刚才插入的ID
	//echo $beian->save()->pkid();

	设置主键然后删除
	//echo($beian->pkid(69)->delete());

	取得表的行数
	//echo $beian->Totalnum();

	select显示两个字段，Arraylist为数组
	//print_r($beian->getAll("userid,language")->record); //改为record了

	查询两个userid和language为1和5，fetch为取值
	print_r($beian->whereUseridAndLanguage('1','5')->fetch()->record);

	取得两个主键，显示三个字段，升序
	//print_r($beian->get('confid,userid,language',53,54,'asc')->record);

	输出主键值
	//echo $beian->confid;

	更新某个表的字段累加1
	$beian->colupdate('tplid');

	可以在model目录下，*****Model.class.php文件里面添加方法。

	生成模型后可以马上可以使用
	print_r($booktype=M("booktype")->getAll());

	关联保存，使用mapper设置，详见supplyModel.class.php文件中
	 var $mapper=array("Books"=>array("map"=>"ManyhasMany","TargetModel"=>"booktype","localFiled"=>"typeid","targetFiled"=>"typeid"));
        
	可以看到是typeid关联，那么M("booktype")会自动得到$supply中typeid的值，如果没有先保存$supply 再次取值
	$supply->get(3,4);
	$supply->up();//edit 3
	M("booktype")->classname="星际解霸2";//设置booktype 类名

        $supply->save(M("booktype"));

常用函数说明

	更新J()跳函数
	可以支持各个路由之间跳转和传递参数
	参数为array
	J("show") 为转到本路由方法show
	J("show",array("id"=>555)) 为转到本路由方法show 并传递参数ID过去
	J(R("member"),"list") 将跳转到member路由上面并调用list方法 如果没有list那么默认为index方法，具体框架中设置的默认方法。
	J("member")
	J("member","list",array("userid"=>999))

	M("模型"); new一个新的模型
	C("类");   new一个正常的php类
模型说明文件
    hasOne hasMany ManyhasMany ORM(Object-Relational Mapper) 对象关系影射有三种可以在"map"=>"hasOne"这里更改
	<?php 
	class supplyModel extends supplyBase{ 
	  var $mapper=array("Books"=>array("map"=>"hasOne","TargetModel"=>"booktype","localFiled"=>"typeid","targetFiled"=>"typeid"));
	  var $maps;
	}
	?>
控制器文件
	index.php/default/index 
	<?php
	class defaultRouter extends controller{
	  function index()
	  {
	    echo "hello world!";
		$this->assign("ssss","aa");
		$this->hhh="88";
		
		$booktype=M("booktype");
		/*
		echo $booktype->fetch('FETCH_OBJ')->up()->bookid;
		print_r($booktype->data);
		echo $booktype->classname;
		*/
		J("saybye",array("bbee"=>6666,"ccdd"=>888));
	  }
	  function saybye()
	  {
		$a=func_get_args();
		print_r($a);
	    echo "bye";
		$supply=M("supply");
		$supply->get(3,4)->up();
		$supply->getDataBaseName();

		echo "===".$supply->Books->Supply->title;
		print_r(M("booktype")->record);	
	  }
	}
	?>
三 数据库表操作

	$supply=M("supply");
	$supply->get(3,4)->up();
	echo ($supply->Books->classname);//自动取得Books中内容
	print_r($supply->record);	
	echo $supply->Books->Supply->title; //反过来取supply中的内容
	print_r(M("booktype")->record);	//booktype中已有对像关系了

	其它使用方法
	可以使用


	M("booktype")->where('name',5555);
	M("booktype")->whereAnd('name',88);
	M("booktype")->whereUserAndLanguage('myname','8')->orderby("id desc")->limit(10)->fetch();
	M("booktype")->orderby("id desc");
	M("booktype")->orderby("desc");
	M("booktype")->groupby("username");
	M("booktype")->limit(10)->fetch();
	M("booktype")->limit(10,20)->fetch();

	取得行总数
	M("booktype")->Totalnum();
	M("booktype")->where('name',5555)->Totalnum();

	更新clicknum字段++数量
	M("booktype")->colupdate("clicknum");//UPDATE table set clicknum=clicknum+1(num) where pkid=M("booktype")->pkik
	M("booktype")->where('name',5555)->colupdate("clicknum");

	取得userid>1 and language<5
	$books->where("userid>1")->whereAnd("language <5")->orderby("desc")->limit(10,20)->fetch();
	print_r($books->record); 

	<form>
	<input name="name" id="name" />
	<input name="sex" id="sex" />
	<input name="age" id="age" />
	......
	</form>

	自动处理post方法
	提交后处理
	$form=M("表名或模型名")->autoField('name','sex','age')->save();
	或处理后数组传入
	$form=M("表名或模型名")->autoField($insertArray,'name','sex','age')->save(); 


	$supply=M("supply");
	$supply->get(3,4);
	$supply->up();//edit 3
	//M("booktype")->classname="星际解霸2";

        $supply->copyRecord()->save(M("booktype")); //自动会从$supply中取得关联值赋给M("booktype");

	$supply->Books=array("classname"=>"星际解霸5"); //支持两个表两个主键之间互联
	print_r($supply->save());                       //支持三个字段关系影射

	//$supply->where($supply->PRI.">12")->delete();
	//$supply->save();
	$books=M("booktype");
	//M("booktype")->where($books->PRI.">12")->delete();
        $supply->Books=array("classname"=>"星际解霸21");//各种插入数据方式
	$supply->Books=array("classname"=>"星际解霸22");
	$supply->Books=array("0"=>array("classname"=>"星际解霸88"),2=>array("classname"=>"星际解霸98"));
	print_r($supply->data);
	$supply->copyRecord()->save();

	  /*
	  * update为指定字段更新，不像save什么都更新
	  * $supply->update('fields,fields');
	  * $supply->update(array('fields'=>"aaabbb","fields2"=>8888));
	  * $supply->update(array('fields'=>"aaabbb","fields2"=>8888),true); //true表示更新到$supply->data
	  * $supply->update($Books); //关联更新 $Books是M对像,表示更新到$supply->data
	  * $books 为类对象，record将会改为对像的。
	  * $supply->update($books,true); 
	  * $supply->update('fields,fields',array("aa","bbb"));
	  */

	$books->get(246)->up(); //取一个值
	$books->classname="开发游戏工业"; //更新字段
	$supply->update($books);  //关联保存


        模型文件配置 可以看到新关联，使用新的sql文件重新创建数据库
	<?php 
	class supplyModel extends supplyBase{ 
	  var $mapper=array("Books"=>array("map"=>"ManyhasMany","TargetModel"=>"booktype","localFiled"=>"typeid","targetFiled"=>"typeid","localFiled2"=>"bookid","targetFiled2"=>"bookid","localFiled3"=>"supplyid","targetFiled3"=>"supplyid"));
	  var $maps;
	  var $maparray=array();
	} 
	?>

config/inc.ini.php文件说明
	在本文件可以设置数据库链接
	/*
	*pdo链接 多少自己填,主从可以一样
	* key 为正则表达式 ^web_开头的表，使用的链接 master为主链接 插入 修改等 slaves为select等操作
	*/
	$pdoconn=array(
	  'default'=>array("master"=>array("0"=>array("dsn"=>"mysql:dbname=mallbook;host=localhost;port=3306","username"=>"admin","password"=>"123456","CHARACTER"=>"utf8"),
					   "1"=>array("dsn"=>"mysql:dbname=mallbook;host=localhost;port=3306","username"=>"admin","password"=>"123456","CHARACTER"=>"utf8")),
			   "slaves"=>array("0"=>array("dsn"=>"mysql:dbname=mallbook;host=localhost;port=3306","username"=>"admin","password"=>"123456","CHARACTER"=>"utf8"))
		);
	//视图设置,默认为空使用自带php模板
	/*
	*  php自带模板意思是在模板中使用php代码foreach(): endforeach if(): else: endif这几种标签当然也可以使用php代码
	*  未来版本视图将将全部是php标签
	*  foreach($row as $key=>$value):
	*  在这里放html代码或做类似Smarty赋值
	*  endforeach;
	*  结束标签 endif;，endwhile; endfor; endforeach; 以及 endswitch;。 
	*/
	//$config['view']="Smarty"; //可以使用Smarty作为视图
	//$config['plugin']=$config["frameworkpath"]."lib";     //插件所在目录，可能会自动搜寻目录
	//$config['frameworklib']=array("Smarty"=>$config["frameworkpath"]."lib/Smarty/Smarty.class.php",
	//                    "SendMail"=>$config["frameworkpath"]."lib/Mail/SendMail.php");//类所在的文件 这具配置可以另外放一个地方
	//配置路由规则login为路由模型 rule为规则 成功后target设置 conditions rule自定义规则对应为:id
	//$config["routermaps"]=array("login",array("rule"=>'/login/:id',
	//		                                    "target"=>array('controller' => 'auth', 'action' => 'login'),
	//		                                    "conditions"=>array('id' => '[\d]{1,8}')));
	//每个project可以配置 内核加前文件precore.ini.php  内核加后文件 aftercore.ini.php 其中precore.ini.php文件是在inc.ini.php(也是本文件)后面加的，这样可以冲抵这个文件设置
	//
单独使用数据库类，有时候你不想使用框架,这样可以把本内核加你的现在现有的项目中了
framework.php
        /*only user modelclass
	*$dispaths=C("router")->setMaps($config["routermaps"])->start();
	*$view=C("view");
	*$router=R($dispaths->controller);
	*if (method_exists($router,$dispaths->action)) {
	*     call_user_func(array($router,$dispaths->action));
	*	 $view->display(R($dispaths->controller)->view($dispaths->action));
	*}
	*/
本内核会自动缓存起来
	缓存文件存放在
	cache/core.cache.php文件就是缓存文件

testproject是项目目录
	本目录是www根
	每个项目都有自己的 
	 config 配置文件目录 precore.ini.php  aftercore.ini.php
	 model  本项目模型文件
	 router 本项目路由文件
	 view   视图文件可以按路由目录存放
	 class  本项目使用的普通类文件
	 lib    存放类库文件或插件
	等目录

自动生成数据库表模型方法
     	 //第一次使用请加上表名"www_channel"这样就会自动生成channel模型了，
	 //生成在model目录下面一个是channelBase.class.php和channelModel.class.php结尾的两个文件
	 //$channel=M("channel","www_channel");
	 //如果已生成过就不用表名了，只有第一次用或数据库更新了需要刷新才使用表名，切记
	 //使用一次后如果正确的那么生成了两个文件，于是赶紧把$channel=M("channel","www_channel");改为
	 //$channel=M("channel"); 这样就可以了不会再去生成那个Base.class.php文件
	 //如果我把数据库表改了一下添加或删除字段
	 //$channel=M("channel","www_channel");再加上表名再去刷新一下那个Base.class.php文件
	 //然后再改回来$channel=M("channel");
	 //正式发布时候我们model目录下已有所有数据库表模型文件了所以我们不会再使用$channel=M("channel","www_channel");加表名了
	 //有点哆嗦，意思是model下面有文件了就不要加表名了

LEFTJOIN 查询方式

	   $booktype=M("booktype");
	   //$booktype->selectSupply("address,title");
       $booktype->selectbooktype("bookid,classname")->selectsupply("address,title")->leftjoin("supply")->joinon("supply.bookid=booktype.bookid")->where('bookid',404)->fetch();
       print_r($booktype->getObjRecord());



下载后
把data目录下testmysql.sql文件导入数据库做测试
把数据库 用户名和密码和数据库名称
framework/config/inc.ini.php 里面修改

PHP code

    /* *pdo链接 多少自己填,主从可以一样 * key 为正则表达式 ^web_开头的表，使用的链接 */ $config['pdoconn']=array( 'default'=>array("master"=>array("0"=>array("dsn"=>"mysql:dbname=mallbook;host=localhost;port=3306","username"=>"admin","password"=>"123456","CHARACTER"=>"utf8")), "slaves"=>array("0"=>array("dsn"=>"mysql:dbname=mallbook;host=localhost;port=3306","username"=>"admin","password"=>"123456","CHARACTER"=>"utf8")) ) );


设置好链接后
可以访问ormtest.php了
http://localhost/queryphp/ormtest.php

看到输出数据库内容了


看看ormtest.php
有什么内容

PHP code

    //产品环境使用(Product) //$projectenv="product"; $projectenv="product"; $config["webprojectpath"]=dirname(__FILE__)."/"; $config["webprojectname"]=strlen($_SERVER['SCRIPT_FILENAME'])."projectname"; //根据项目来缓存,所以最好一个网站不要一样 include($config["webprojectpath"]."framework/queryorm.php");



原来只包含一个queryorm.php文件就可以了
我们可以在我们现在的项目或程序中包含这个文件就可以了

PHP code

    $supply=M("supply"); //表示生成一个数据库模型 $supply->get(3,4); //表示取得两条主键为3 4的两条记录 print_r($supply->record); array ( 0 => array ( 'supplyid' => '3', 'typeid' => '1', 'bookid' => '410', 'userid' => '0', 'total' => '0', 'isView' => 'Y', 'author' => '', 'linkname' => '', 'phone' => '', 'isPic' => 'N', 'mobile' => '13800138000', 'address' => '上地站', 'email' => '', 'msn' => '', 'qq' => '', 'title' => 'ssssssss', 'dest' => '', 'picurl' => '', 'srcpri' => '0.00', 'outpri' => '0.00', 'per' => '0.0', 'press' => '', 'adddate' => '2007-10-06', 'content' => 'ssssssssssss', ), 1 => array ( 'supplyid' => '4', 'typeid' => '2', 'bookid' => '0', 'userid' => '0', 'total' => '0', 'isView' => 'Y', 'author' => '', 'linkname' => '', 'phone' => '', 'isPic' => '', 'mobile' => '', 'address' => '天津河东', 'email' => '', 'msn' => '', 'qq' => '', 'title' => '标题', 'dest' => '', 'picurl' => '', 'srcpri' => '0.00', 'outpri' => '0.00', 'per' => '0.0', 'press' => '', 'adddate' => '2007-10-06', 'content' => '内容', ), ) $supply->up();//edit 3 编辑刚才那两条记录第一行记录内容 //up执行后 $supply->data就有数据了 //有点类似$result[0];样子 //如果再up一次就是$result[1] 如果最后没有了就会变成空了 //当然也可以 $rowobj=$supply->getObjRecord(); $row=$supply->getRecord(); //这两个都是取得$supply->record; //取回所有record数据



现在我在数据库中添加了一个info表怎么办
假设在数据库中添加一个info表字段也设置好了
那么我们来生成info数据库模型

我们在程序中写一句
$supply=M("info");
就可以自动生成了info数据库模型了
可以在
framework/model目录下面看到多了两个文件
infoModel.class.php infoBase.class.php
infoBase.class.php  是数据库表的基本信息，这个不用理
infoModel.class.php 是模型文件可以在这里添加其实方法 比如->setpassword($pwd);

PHP code

    function setpassword($pwd) { $this->data['password']=md5($pwd); return $this; }

 
             
是不是很简单
但是如果我的表是www_info表怎么办呢，这种就是加了前辍的表
我的模型总不能有前辍吧
看看document里面文档说明
    //第一次使用请加上表名"www_channel"这样就会自动生成channel模型了，
//生成在model目录下面一个是channelBase.class.php和channelModel.class.php结尾的两个文件
//$channel=M("channel","www_channel");
//如果已生成过就不用表名了，只有第一次用或数据库更新了需要刷新才使用表名，切记
//使用一次后如果正确的那么生成了两个文件，于是赶紧把$channel=M("channel","www_channel");改为
//$channel=M("channel"); 这样就可以了不会再去生成那个Base.class.php文件
//如果我把数据库表改了一下添加或删除字段
//$channel=M("channel","www_channel");再加上表名再去刷新一下那个Base.class.php文件
//然后再改回来$channel=M("channel");
//正式发布时候我们model目录下已有所有数据库表模型文件了所以我们不会再使用$channel=M("channel","www_channel");加表名了
//有点哆嗦，意思是model下面有文件了就不要加表名了

那么我们使用$info=M("info","www_info");就可以生成了
framework/model目录下面 infoModel.class.php infoBase.class.php
删除 把访问一次
http://localhost/queryphp/ormtest.php

是不是又生成了两个文件跟刚才一样
infoBase.class.php
var $tablename='www_info'; //这个才是表名


下面说说怎么就用操作数据据库了
$supply->where($supply->pkidkey().">12")->delete();
表示删除主键大于12的
现在我们做下查询
$supply->whereuseridANDbookid(12,9)->fetch();
表示要取得userid=12 and bookid=9记录

$supply->whereuseridORbookid(12,9)->fetch();
表示要取得userid=12 OR bookid=9记录

$supply->whereuseridIN(12,9)->fetch();
表示要取得userid IN (12,9)记录

        $supply->up(0);
$supply->address="北京海淀区";
$supply->update("address");
        修改$supply->record[0]中记录
        我们只更新address字段
       
        我们想复制一行
        那么还是操作刚才那个 $supply->up(0);
        因为数据还留在$supply->data中
        我们复制一个
        $supply->copyRecord()->save();
        这样就可以新插入数据了
        copyRecord()作用是把data中数据主键删除，没有主键保存那么会以插放方式 



新应用，关联查询

PHP code

    $supply=M("supply"); 
$supply->get(3,4)->up(); 
//把3设置为编辑状态 
$books=M("booktype"); 
$books->get(411)->up(); 
//取得id为411的行 并设置为编辑状态 
$info=M("info")->limit(1)->fetch()->up(); 
//取得info一行记录并设置编辑状态 
$supply->Books($books)->Infos($info)->fetch(); 
//关联查询 
//有点类似这样子 
where("bookid='".$books->bookid."' and typeid='".$infos->infoid."'")->fetch();
 //当然这样也行 只要设置了$books,$infos有数据为编辑状态后 
$supply->Books()->Infos()->fetch(); //是一样的。 
print_r($supply->getRecord());



也有一些新的where条件设置方法

PHP code

    //$supply->findBySupplyidDY("12"); where supplyid>'12' //DY表示大于 //AND|OR|LIKE|DY|DD|XY|XD|BD|ISNULL|NOTNULL|IN|NOTIN|NOTEQ|EQ 
//             > >= <  <= !=                         != = //对应的符号
 //$supply->whereuseridORbookid(12,9); 
where userid='12' OR bookid='9'
 //像用户登录时候查询经常用到 
//$supply->whereUseridANDBookid(12,9);
 where userid='12' AND bookid='9'
 //$supply->findBybookidORuseridINaddress(12,array(77,56,8,9),'cname');
 where bookid='12' OR userid IN (77,56,8,9) AND address='cname'


去除index.php测试

C:\WINDOWS\system32\drivers\etc\hosts文件添加一行
内容如下
127.0.0.1       localhost
192.168.0.10	www.app.com

192.168.0.10的是你自己apache使用的IP,就是下面<VirtualHost *:80>
*号中的IP，反证能访问你的本地网卡就可以了

http://www.app.com/queryphp/project/index.php/default/index
配置后希望可以变成这样子
http://www.app.com/queryphp/project/default/index.html
记得在inc.ini.php文件里面加多一行
 $config['html']='.html'; 或把前面那个//去掉，这样就可以了
虚拟主机配置测试，AllowOverride FileInfo 将会使用.htaccess配置
<VirtualHost *:80>
    <Directory "D:/work">
        Order allow,deny
        Allow from all
	AllowOverride FileInfo 
    </Directory> 
  DocumentRoot "D:/work"
  ServerName "www.app.com"
</VirtualHost>


.htaccess文件 放在project目录下面 就是每个项目目录下面，这样就会访问同级目录
index.php文件

  RewriteEngine On

  # uncomment the following line, if you are having trouble
  # getting no_script_name to work
  #RewriteBase /

  # we skip all files with .something
  #RewriteCond %{REQUEST_URI} \..+$
  #RewriteCond %{REQUEST_URI} !\.html$
  #RewriteRule .* - [L]

  # we check if the .html version is here (caching)
  RewriteRule ^$ index.html [QSA]
  RewriteRule ^([^.]+)$ $1.html [QSA]
  RewriteCond %{REQUEST_FILENAME} !-f

  # no, so we redirect to our front web controller
  RewriteRule ^(.*)$ index.php [QSA,L]


------------------------------------------------------------
程序中使用url_for()方式


模板中示示例 我们还是以CURD方式 

    <td><a href="<?php echo url_for("curd/edit/id/".$value['bookid'])?>">编辑</a></td>
    <td><a href="<?php echo url_for("curd/delete/id/".$value['bookid'])?>">删除</a></td>

下载后在并在apache设置www.app.com 在c:/windows/system
http://www.app.com/queryphp/project/curd/index

是不是可以显示内容了


如果显示了 在framework\config\inc.ini.php 文件中把下面这行内容去掉注释
//$config['html']='.html';//开启.html结尾url


http://www.app.com/queryphp/project/curd/index.html 访问
是不是可以看到内容了

所有链接都带.html结尾了。那我们有时候想不要.html结尾怎么办
<a href="<?php echo url_for("curd/delete/id/".$value['bookid'],true)?>">删除</a>

url_for(url,true);方式 表示不要html结尾
删除会变成这样子
http://www.app.com/queryphp/project/curd/delete/id/2
